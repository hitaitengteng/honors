Will Gantt
1/10/17

---------------------------------------------------------------------------
A. KNOWLEDGE REPRESENTATION
---------------------------------------------------------------------------

I. RULES

	Rules will be represented as objects, the EO library permitting.
	Failing that, they will be represented as structs. In either case,
	a rule will contain the elements listed below. Sets of rules will
	simply be vectors of rule objects/structs.

II. CONDITION

	Conditions will be represented as arrays of attribute objects (or
	structs). I have not decided whether an attribute should contain
	its name (or ID number), or whether its identity should be denoted
	merely by its position in the array. Regardless, since nearly all
	of the attributes in Erik's data are real-valued, an attribute in
	a rule will specify a range of possible values by a CENTER variable
	and a SPREAD variable.

	To allow for the "don't care" values used in traditional LCSs, a
	condition will contain a boolean variable DONT_CARE which will
	have value 1 if the attribute is a "don't care" and will have value
	0 otherwise.

III. CLASS

	It remains to be decided how change in yield, the class attribute,
	will be discretized. My current thinking is to use the schema
	{HP, LP, LN, HN}, where the values denote "High positive," "Low
	positive," "Low negative," and "High negative" change. Each class
	will be associated with some integer value.

IV. ACCURACY

	This measures the ratio of the number of inputs that the rule
	matches AND correctly classifies to the number of inputs that the
	rule matches. The accuracy variable, ACC, will be a double.

	An alternative: instead of maintaining accuracy as its own variable
	a rule might rather maintain the number of input matches and the
	number of input matches that it correctly classifies. This actually
	makes the fitness update easier, so I will assume that this is the
	way things are to be done.

V. FITNESS

	This LCS is an accuracy-based LCS, and so fitness will be based on
	accuracy. In the UCS paper, the authors define the fitness, F, of
	a rule as F = ACC^v, where v is some constant. The utility of
	raising the accuracy variable to some constant to obtain the
	fitness (as opposed to merely using accuracy AS fitness) eludes me.
	Until I can determine why this is done, accuracy and fitness will
	be a single variable.

VI. NUMEROSITY

	The number of copies of the rule in the population. This variable,
	NUM, will be an integer.

VII. NICHE SET SIZE

	The average size of the correct sets to which the rule belongs.
	NS will be a double.

---------------------------------------------------------------------------
B. PERFORMANCE COMPONENT
---------------------------------------------------------------------------

I. INPUTS

	Currently, inputs are read in as attribute vectors, but this ought
	to be fixed, as they can just as easily (and more economically) be
	represented as simple vectors of real values, so long as a given
	attribute is associated with a particular location in the vector.

	An input matches a rule iff for each input attribute value e_i,
	either:

		1. e_i falls within the range specified by the
		   corresponding rule attribute x_i.
		2. x_i has the DONT_CARE variable set to TRUE.

II. MATCH SET CONSTRUCTION

	Inputs are fed to the system one-by-one at the beginning of each
	iteration of the algorithm. It must then be determined which, if
	any, of the rules in the population set [P] match the input. Each
	rule is checked according to the procedure above and, if it is
	found to match the input, is added to the match set [M] (a vector
	of rules) and NUM_MATCHES is incremented (see IV). If no match is 
	found, the covering operator is invoked	(see C-II). 

III. CORRECT SET CONSTRUCTION

	This step is simultaneous with the construction of the match set.
	If a rule is found to match the input, the rule's class is then
	checked against that of the input. If they match here as well,
	then the rule is added to the correct set [C] (also a vector
	of rules), and NUM_CORRECT is updated (see IV). 

IV. FITNESS UPDATE

	Assuming that rules maintain a variable for the number of matches
	(call it NUM_MATCHES) and a variable for the number of matches it
	correctly classifies (NUM_CORRECT), the fitness update takes care
	of itself, as both values will have been adjusted where necessary
	in the match set and correct set constructions.

V. SPECIFY OPERATOR [INCOMPLETE]

	This is an operator designed to reduce the number of overly
	general rules, which can prevent effective learning. 

VI. REDUNDANCY ELIMINATION [INCOMPLETE]

	[How to deal with conflicting rules?]

---------------------------------------------------------------------------
C. LEARNING COMPONENT
---------------------------------------------------------------------------

I. GENETIC ALGORITHM

	(a) Initialization.

		The size of [P] will be specified on the command line.
		For each rule, the following values are set to 0:
		accuracy/fitness (ACC/F), match set size (NUM_MATCH),
		correct set size (NUM_CORRECT), and niche set size
		(AVG_NICHE_SIZE). The class will be chosen randomly,
		and the CENTER and SPREAD for each attribute will also
		be selected randomly, keeping in mind the range of
		values of each attribute actually represented by the
		inputs.

	(b) Evaluation/Fitness Update.
		
		The fitness update occurs only when a new input is
		processed and is computed using the formula described
		in B-IV.

	(c) Selection.

		A single set of parents is chosen from [C] via
		roulette wheel selection.

	(d) Crossover.

		The parents are crossed (using 1-pt crossover) with
		some probability.

	(e) Mutation.

		This will involve a slight tweaking of the CENTER and
		SPREAD variables for each attribute, but I need to do
		more research to determine how this is best done.

	(f) Subsumption/Replacement.

		If the fitter of a set of parents is sufficiently experienced
		(EXP > EXP_THRESH) and accurate (ACC > ACC_THRESH), and
		is more general than a given offspring, then that offspring
		is deleted and the numerosity of the parent is increased
		(this is known as "subsumption"). Note that the only actual
		comparison being made between the parent and the offspring
		is in terms of generality (the accuracy and experience
		variables of the offspring are set to 0). If the fitter parent 
		does not meet these criteria, the offspring is added to the
		population. 

		Another rule from the population must then be deleted. The
		probability that a rule will chosen for deletion is
		proportional to the AVG_NICHE_SIZE variable. I have not
		decided whether or how other factors, like experience and
		accuracy, should play a role in this calculation.

II. COVERING OPERATOR


